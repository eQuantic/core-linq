using System.Linq;
using System.Text;
using eQuantic.Linq.SourceGenerator.Models;

namespace eQuantic.Linq.SourceGenerator.Generators;

internal static class FilterCodeGenerator
{
    public static string Generate(ClassInfo classInfo)
    {
        var sb = new StringBuilder();
        var namespaceName = classInfo.Configuration.Namespace ?? classInfo.Namespace;

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using eQuantic.Linq.Filter;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public partial class {classInfo.Name}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Generated filters for {classInfo.Name}");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static class Filters");
        sb.AppendLine("    {");

        foreach (var property in classInfo.Properties.Where(p => p.Configuration?.Exclude != true))
        {
            GeneratePropertyFilters(sb, classInfo.Name, property);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GeneratePropertyFilters(StringBuilder sb, string className, PropertyInfo property)
    {
        var propertyName = property.Name;
        var propertyType = property.Type;
        var methodName = property.Configuration?.MethodName ?? propertyName;

        // Generate main filter method with operator parameter
        sb.AppendLine($"        /// <summary>");
        sb.AppendLine($"        /// Creates a filter for {propertyName} with the specified operator and value.");
        sb.AppendLine($"        /// </summary>");
        sb.AppendLine($"        public static IEntityFilter<{className}> By{methodName}({propertyType} value, FilterOperator op = FilterOperator.Equal)");
        sb.AppendLine("        {");
        sb.AppendLine("            return op switch");
        sb.AppendLine("            {");
        
        GenerateOperatorCases(sb, className, property, methodName);
        
        sb.AppendLine($"                _ => throw new NotSupportedException($\"Operator {{op}} not supported for {propertyType} property {propertyName}\")");
        sb.AppendLine("            };");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate specific method overloads for common operations
        GenerateSpecificFilterMethods(sb, className, property, methodName);
    }

    private static void GenerateOperatorCases(StringBuilder sb, string className, PropertyInfo property, string methodName)
    {
        var propertyName = property.Name;
        var propertyType = property.Type;

        // Always generate Equal
        sb.AppendLine($"                FilterOperator.Equal => EntityFilter<{className}>.Where(x => x.{propertyName} == value),");

        if (IsStringType(propertyType))
        {
            sb.AppendLine($"                FilterOperator.Contains => EntityFilter<{className}>.Where(x => x.{propertyName} != null && x.{propertyName}.Contains(value)),");
            sb.AppendLine($"                FilterOperator.StartsWith => EntityFilter<{className}>.Where(x => x.{propertyName} != null && x.{propertyName}.StartsWith(value)),");
            sb.AppendLine($"                FilterOperator.EndsWith => EntityFilter<{className}>.Where(x => x.{propertyName} != null && x.{propertyName}.EndsWith(value)),");
        }

        if (IsNumericType(propertyType) || IsDateTimeType(propertyType))
        {
            sb.AppendLine($"                FilterOperator.GreaterThan => EntityFilter<{className}>.Where(x => x.{propertyName} > value),");
            sb.AppendLine($"                FilterOperator.LessThan => EntityFilter<{className}>.Where(x => x.{propertyName} < value),");
            sb.AppendLine($"                FilterOperator.GreaterThanOrEqual => EntityFilter<{className}>.Where(x => x.{propertyName} >= value),");
            sb.AppendLine($"                FilterOperator.LessThanOrEqual => EntityFilter<{className}>.Where(x => x.{propertyName} <= value),");
        }

        sb.AppendLine($"                FilterOperator.NotEqual => EntityFilter<{className}>.Where(x => x.{propertyName} != value),");
    }

    private static void GenerateSpecificFilterMethods(StringBuilder sb, string className, PropertyInfo property, string methodName)
    {
        var propertyName = property.Name;
        var propertyType = property.Type;

        if (IsStringType(propertyType))
        {
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Creates a filter that checks if {propertyName} contains the specified value.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static IEntityFilter<{className}> {methodName}Contains(string value)");
            sb.AppendLine($"            => EntityFilter<{className}>.Where(x => x.{propertyName} != null && x.{propertyName}.Contains(value));");
            sb.AppendLine();

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Creates a filter that checks if {propertyName} starts with the specified value.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static IEntityFilter<{className}> {methodName}StartsWith(string value)");
            sb.AppendLine($"            => EntityFilter<{className}>.Where(x => x.{propertyName} != null && x.{propertyName}.StartsWith(value));");
            sb.AppendLine();

            if (property.IsNullable)
            {
                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Creates a filter that checks if {propertyName} is null or empty.");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        public static IEntityFilter<{className}> {methodName}IsNullOrEmpty()");
                sb.AppendLine($"            => EntityFilter<{className}>.Where(x => string.IsNullOrEmpty(x.{propertyName}));");
                sb.AppendLine();
            }
        }

        if (IsNumericType(propertyType) || IsDateTimeType(propertyType))
        {
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Creates a filter that checks if {propertyName} is greater than the specified value.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static IEntityFilter<{className}> {methodName}GreaterThan({propertyType} value)");
            sb.AppendLine($"            => EntityFilter<{className}>.Where(x => x.{propertyName} > value);");
            sb.AppendLine();

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Creates a filter that checks if {propertyName} is between the specified values.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static IEntityFilter<{className}> {methodName}Between({propertyType} min, {propertyType} max)");
            sb.AppendLine($"            => EntityFilter<{className}>.Where(x => x.{propertyName} >= min && x.{propertyName} <= max);");
            sb.AppendLine();
        }

        if (IsBooleanType(propertyType))
        {
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Creates a filter that checks if {propertyName} is true.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static IEntityFilter<{className}> {methodName}IsTrue()");
            sb.AppendLine($"            => EntityFilter<{className}>.Where(x => x.{propertyName});");
            sb.AppendLine();

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Creates a filter that checks if {propertyName} is false.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public static IEntityFilter<{className}> {methodName}IsFalse()");
            sb.AppendLine($"            => EntityFilter<{className}>.Where(x => !x.{propertyName});");
            sb.AppendLine();
        }
    }

    private static bool IsStringType(string type) => 
        type == "string" || type == "System.String" || type.EndsWith("string?");

    private static bool IsNumericType(string type) =>
        type == "int" || type == "long" || type == "float" || type == "double" || type == "decimal" || 
        type == "byte" || type == "short" || type == "uint" || type == "ulong" || type == "ushort" ||
        type == "System.Int32" || type == "System.Int64" || type == "System.Single" || type == "System.Double" || type == "System.Decimal" || 
        type == "System.Byte" || type == "System.Int16" || type == "System.UInt32" || type == "System.UInt64" || type == "System.UInt16" ||
        type.EndsWith("int?") || type.EndsWith("long?") || type.EndsWith("float?") || type.EndsWith("double?") || type.EndsWith("decimal?");

    private static bool IsBooleanType(string type) =>
        type == "bool" || type == "System.Boolean" || type.EndsWith("bool?");

    private static bool IsDateTimeType(string type) =>
        type == "DateTime" || type == "System.DateTime" || type == "DateTimeOffset" || type == "System.DateTimeOffset" || 
        type == "DateOnly" || type == "System.DateOnly" ||
        type.EndsWith("DateTime?") || type.EndsWith("DateTimeOffset?") || type.EndsWith("DateOnly?");
}