using System.Linq;
using eQuantic.Linq.SourceGenerator.Models;

namespace eQuantic.Linq.SourceGenerator.Generators;

internal static class SpecificationCodeGenerator
{
    public static string Generate(ClassInfo classInfo)
    {
        var writer = new CodeWriter();
        var namespaceName = classInfo.Configuration.Namespace ?? classInfo.Namespace;

        writer.AppendLine("// <auto-generated />");
        writer.AppendLine("#nullable enable");
        writer.AppendLine();
        writer.AppendLine("using System;");
        writer.AppendLine("using System.Linq.Expressions;");
        writer.AppendLine("using eQuantic.Linq.Specification;");
        writer.AppendLine();
        writer.AppendLine($"namespace {namespaceName};");
        writer.AppendLine();

        using (writer.BeginScope($"public partial class {classInfo.Name}"))
        {
            writer.AppendXmlDocSummary($"Generated specifications for {classInfo.Name}");
            using (writer.BeginScope($"public static class Specifications"))
            {
                foreach (var property in classInfo.Properties.Where(p => p.Configuration?.Exclude != true))
                {
                    GeneratePropertySpecifications(writer, classInfo.Name, property);
                }
            }
        }

        return writer.ToString();
    }

    private static void GeneratePropertySpecifications(CodeWriter writer, string className, PropertyInfo property)
    {
        var propertyName = property.Name;
        var propertyType = property.Type;
        var methodName = property.Configuration?.MethodName ?? propertyName;

        // Generate basic equality specification
        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} equals the specified value.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}Equals({propertyType} value)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} == value);");
        writer.AppendLine();

        // Generate type-specific specifications
        if (IsStringType(propertyType))
        {
            GenerateStringSpecifications(writer, className, property, methodName);
        }
        else if (IsNumericType(propertyType))
        {
            GenerateNumericSpecifications(writer, className, property, methodName);
        }
        else if (IsBooleanType(propertyType))
        {
            GenerateBooleanSpecifications(writer, className, property, methodName);
        }
        else if (IsDateTimeType(propertyType))
        {
            GenerateDateTimeSpecifications(writer, className, property, methodName);
        }
    }

    private static void GenerateStringSpecifications(CodeWriter writer, string className, PropertyInfo property, string methodName)
    {
        var propertyName = property.Name;

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} contains the specified value.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}Contains(string value)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} != null && x.{propertyName}.Contains(value));");
        writer.AppendLine();

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} starts with the specified value.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}StartsWith(string value)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} != null && x.{propertyName}.StartsWith(value));");
        writer.AppendLine();

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} ends with the specified value.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}EndsWith(string value)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} != null && x.{propertyName}.EndsWith(value));");
        writer.AppendLine();

        if (property.IsNullable)
        {
            writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is null or empty.");
            writer.AppendLine($"public static ISpecification<{className}> {methodName}IsNullOrEmpty()");
            writer.AppendLine($"    => new DirectSpecification<{className}>(x => string.IsNullOrEmpty(x.{propertyName}));");
            writer.AppendLine();
        }
    }

    private static void GenerateNumericSpecifications(CodeWriter writer, string className, PropertyInfo property, string methodName)
    {
        var propertyName = property.Name;
        var propertyType = property.Type;

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is greater than the specified value.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}GreaterThan({propertyType} value)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} > value);");
        writer.AppendLine();

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is less than the specified value.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}LessThan({propertyType} value)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} < value);");
        writer.AppendLine();

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is between the specified values.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}Between({propertyType} min, {propertyType} max)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} >= min && x.{propertyName} <= max);");
        writer.AppendLine();
    }

    private static void GenerateBooleanSpecifications(CodeWriter writer, string className, PropertyInfo property, string methodName)
    {
        var propertyName = property.Name;

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is true.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}IsTrue()");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName});");
        writer.AppendLine();

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is false.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}IsFalse()");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => !x.{propertyName});");
        writer.AppendLine();
    }

    private static void GenerateDateTimeSpecifications(CodeWriter writer, string className, PropertyInfo property, string methodName)
    {
        var propertyName = property.Name;
        var propertyType = property.Type;

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is after the specified date.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}After({propertyType} date)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} > date);");
        writer.AppendLine();

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is before the specified date.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}Before({propertyType} date)");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName} < date);");
        writer.AppendLine();

        writer.AppendXmlDocSummary($"Creates a specification that checks if {propertyName} is today.");
        writer.AppendLine($"public static ISpecification<{className}> {methodName}IsToday()");
        writer.AppendLine($"    => new DirectSpecification<{className}>(x => x.{propertyName}.Date == DateTime.Today);");
        writer.AppendLine();
    }

    private static bool IsStringType(string type) => 
        type == "string" || type == "System.String" || type.EndsWith("string?");

    private static bool IsNumericType(string type) =>
        type == "int" || type == "long" || type == "float" || type == "double" || type == "decimal" || 
        type == "byte" || type == "short" || type == "uint" || type == "ulong" || type == "ushort" ||
        type == "System.Int32" || type == "System.Int64" || type == "System.Single" || type == "System.Double" || type == "System.Decimal" || 
        type == "System.Byte" || type == "System.Int16" || type == "System.UInt32" || type == "System.UInt64" || type == "System.UInt16" ||
        type.EndsWith("int?") || type.EndsWith("long?") || type.EndsWith("float?") || type.EndsWith("double?") || type.EndsWith("decimal?");

    private static bool IsBooleanType(string type) =>
        type == "bool" || type == "System.Boolean" || type.EndsWith("bool?");

    private static bool IsDateTimeType(string type) =>
        type == "DateTime" || type == "System.DateTime" || type == "DateTimeOffset" || type == "System.DateTimeOffset" || 
        type == "DateOnly" || type == "System.DateOnly" ||
        type.EndsWith("DateTime?") || type.EndsWith("DateTimeOffset?") || type.EndsWith("DateOnly?");
}